#################################### List of the needed functions : go directly to line 245 for the main code ################################################# 

# Œ±‚Çô for the trace operator (see Section 3.2).
function Œ±‚Çô(n)
    if n[1] == n[2] == 0
        return 1
    elseif n[1] == n[2] != 0
        return 4
    elseif (n[1] != 0) & (n[2] == 0)
        return 2
    else
        return 4
    end
end

# Computes the trace for a D‚ÇÑFourier sequence.
function _trace_D‚ÇÑ(N)
    M = dimension(D‚ÇÑFourier(N,1.0))
    S = zeros(N+1,M)
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = 0:N
            m = (max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))
            Œ± = Œ±‚Çô(m)
            S[n‚ÇÅ+1,m[1] + m[2]*N - div(((m[2]-2)^2 + 3*(m[2]-2)),2)] = Œ±*(-1)^n‚ÇÇ
        end
    end
    return S
end

# Allows us to switch between D‚ÇÑ and exponential Fourier series
function _exp2D‚ÇÑ!(D::Vector{Float64},s::D‚ÇÑFourier)
    k = 1
    ord = order(s)[1]
    for k‚ÇÇ = 0:ord
        for k‚ÇÅ = k‚ÇÇ:ord
            if k‚ÇÅ == k‚ÇÇ == 0
                D[k] = 1
                k += 1
            elseif k‚ÇÅ == k‚ÇÇ != 0
                D[k] = sqrt(4)
                k += 1
            elseif (k‚ÇÅ != 0) & (k‚ÇÇ == 0)
                D[k] = sqrt(4)
                k += 1
            else
                D[k] = sqrt(8)
                k +=1 
            end
        end
    end
    return D
end

# Allows us to switch between D‚ÇÇ and exponential Fourier series
function exp2cos(N)

    d = 2*((ones((N+1)^2)))

    d[1] = 1;
    for n2=1:N
        d[n2+1] = sqrt(2);
    end

    for n1 = 1:N
        d[n1*(N+1)+1] = sqrt(2);
    end

    return d
end

# Computes convolution of D‚ÇÑFourier sequences up to order N
function _conv_small(u,v,N)
    #Computes u*v only up to order N
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(D‚ÇÑFourier(N,frequency(u)[1]), interval.(zeros(dimension(D‚ÇÑFourier(N,frequency(u)[1])))))
    for i‚ÇÇ ‚àà 0:N
        for i‚ÇÅ ‚àà i‚ÇÇ:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (max(abs(j‚ÇÅ),abs(j‚ÇÇ)),min(abs(j‚ÇÅ),abs(j‚ÇÇ)))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Performs convolution up to order N of a D‚ÇÑ and D‚ÇÇ Fourier series
function __conv_small(u,v,N)
    #Computes u*v up to order N
    #u is a sequence in D‚ÇÑFourier
    #v is a sequence in CosFourier ‚äó CosFourier (D‚ÇÇ symmetric)
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(CosFourier(N,frequency(u)[1])‚äóCosFourier(N,frequency(u)[1]), interval.(zeros((N+1)^2)))
    for i‚ÇÅ ‚àà 0:N
        for i‚ÇÇ ‚àà 0:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (abs(j‚ÇÅ),abs(j‚ÇÇ))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Computes convolution of D‚ÇÑFourier sequences up to order N
function _conv_smallbig(u,v,N)
    #Computes u*v only up to order N
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(D‚ÇÑFourier(N,frequency(u)[1]), interval.(big.(zeros(dimension(D‚ÇÑFourier(N,frequency(u)[1]))))))
    for i‚ÇÇ ‚àà 0:N
        for i‚ÇÅ ‚àà i‚ÇÇ:N
            C·µ¢ = interval(zero(BigFloat))
            setprecision(80)
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (max(abs(j‚ÇÅ),abs(j‚ÇÇ)),min(abs(j‚ÇÅ),abs(j‚ÇÇ)))
                    setprecision(80)
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Performs the estimate of Lemma 4.1
function œÜ(A,B,C,D)
    O‚ÇÅ = max(A,D) + max(B,C)
    O‚ÇÇ = sqrt(A^2 + D^2 + B^2 + C^2)
    return min(O‚ÇÅ,O‚ÇÇ)
end


function sinc_int(x)
        N = 8
        f = interval(big(0))
        for n=0:N 
            f = f + ExactReal(-1^n)*x^(2*n+1)/interval(big(factorial(2*n+1)))
        end 
        Œæ = interval(big(0.1))^(2*(N+1)+1)/((ExactReal(1)-interval(big(0.1)))*interval(big(factorial(2*(N+1)+1))))
        f = interval(inf(f)-sup(Œæ),sup(f)+sup(Œæ))
    return f 
end


# Computes the Fourier coefficients of 1_ùíü‚ÇÄ¬≤
function _char_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f)‚äóFourier(N,f), interval.(complex.(big.(zeros((2N+1)^2)))))
    for n‚ÇÇ = -N:N
        for n‚ÇÅ = -N:N
            char[(n‚ÇÅ,n‚ÇÇ)] = interval(big(1))/(interval(big(4))*d^2) * exp(1im*n‚ÇÅ*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1))))*exp(1im*n‚ÇÇ*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1)))) * sinc_int(n‚ÇÅ/d*interval(big(1/2)))*sinc_int(n‚ÇÇ/d*interval(big(1/2)))
        end
    end
    rchar = Sequence(D‚ÇÑFourier(N,f), interval.(big.(zeros(dimension(D‚ÇÑFourier(N,f))))))
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = n‚ÇÇ:N
            rchar[(n‚ÇÅ,n‚ÇÇ)] = real(char[(n‚ÇÅ,n‚ÇÇ)] + char[(n‚ÇÇ,-n‚ÇÅ)] + char[(-n‚ÇÅ,-n‚ÇÇ)] + char[(-n‚ÇÇ,n‚ÇÅ)])
        end
    end
    return rchar
end

# Computes the sequence a(d,‚ãÖ) for a in D‚ÇÑFourier.
function _sequence_on_boundary(a)
    N = order(a)[1]
    f = frequency(a)[1]
    anew = Sequence(CosFourier(N,f), interval.(big.(zeros(N+1))))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = -N:N
            anew[n‚ÇÅ] += a[(max(n‚ÇÅ,abs(n‚ÇÇ)),min(n‚ÇÅ,abs(n‚ÇÇ)))]*(-1)^n‚ÇÇ
        end
    end
    return anew
end

# Computes the Fourier coefficients of 1_ùíü‚ÇÄ
function _char_1D_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f), interval.(complex.(big.(zeros((2N+1))))))
    for n = -N:N
        char[n] = interval(big(1))/(interval(big(2))*d) * exp(1im*n*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1)))) * sinc_int(n/d*interval(big(1/2)))
    end
    rchar = Sequence(CosFourier(N,f), interval.(big.(zeros(N+1))))
    for n = 0:N
        rchar[n] = real(char[n] + char[-n])
    end
    return rchar
end

# Computes the function needed to take the convolution with ‚àÇ‚Çì‚ÇÅV‚ÇÅ·¥∫
# We denote by (·πº‚±º)‚Çò = |mÃÉ‚ÇÅ| (V‚±º·¥∫)‚Çò 
function _·πº‚±º_coeffs(V‚±º·¥∫)
    N = order(V‚±º·¥∫)[1]
    f = frequency(V‚±º·¥∫)[1]
    ·πº‚±º = Sequence(CosFourier(N,f)‚äóCosFourier(N,f), interval.(big.(zeros((N+1)^2))))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = 0:N
            ·πº‚±º[(n‚ÇÅ,n‚ÇÇ)] = abs(n‚ÇÅ)*f*V‚±º·¥∫[(max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))]
        end
    end
    return ·πº‚±º
end

# Checks the conditions of the Radii-Polynomial Theorem 3.1.
function CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ,ùíµ‚ÇÇ,r‚ÇÄ)
    if ùíµ‚ÇÅ + ùíµ‚ÇÇ*r‚ÇÄ < 1
        if interval(1/2)*ùíµ‚ÇÇ*r‚ÇÄ^2 - (interval(1)-ùíµ‚ÇÅ)*r‚ÇÄ + ùí¥‚ÇÄ < 0
          display("The proof was successful for r‚ÇÄ = ")
          display(sup(r‚ÇÄ))  
        else
          display("The condition 2ùí¥‚ÇÄ*ùíµ‚ÇÇ < (1-ùíµ‚ÇÅ)¬≤ is not satisfied")
        end
    else
        if ùíµ‚ÇÅ > 1
            display("ùíµ‚ÇÅ is too big")
        else
          display("failure: linear term is positive")
        end
      end
end




function D4_2_Cos(U)
    N = order(space(U))[1]
    f = frequency(U)[1]
    V = Sequence(CosFourier(N,f)‚äóCosFourier(N,f),interval.(big.(zeros((N+1)^2))))
    for n1 = 0:N
        for n2 = 0:n1-1 
            V[(n1,n2)] = U[(n1,n2)]
        end 
        for n2 = n1:N 
            V[(n1,n2)] = U[(n2,n1)]
        end 
    end
    return V 
end 



### We adapt the code given at https://github.com/dominicblanco/LocalizedPatternsGS.jl for the computation of ùíµu 
### In particular we compute it in the worst case scenario, that is when Œº = Œ¥0 
function computation_Zu(V1,V2,d,N)
    # Computation of the ùíµ·µ§‚ÇÅ bound defined in Lemma 4.9.
print("Starting ùíµ·µ§")
setprecision(80)
a‚ÇÅbig = sqrt((ExactReal(1)-Œ¥0big)/Œª1big)
setprecision(80)
a‚ÇÇbig = sqrt(Œª2big-Œ¥0big)
a‚ÇÅ = sqrt((interval(1)-Œ¥0)/Œª1)
a‚ÇÇ = sqrt(Œª2-Œ¥0)
# The constants C‚ÇÄf‚ÇÅ‚ÇÅ and C‚ÇÄf‚ÇÇ‚ÇÇ in Lemma 4.8
C‚ÇÄf‚ÇÅ‚ÇÅ = max(a‚ÇÅ^2*interval(interval(2)*exp(interval(5/4)))*(interval(2)/a‚ÇÅ)^(interval(1/4)),a‚ÇÅ^2*sqrt(interval(œÄ)/(interval(2)*sqrt(a‚ÇÅ))))
C‚ÇÄf‚ÇÇ‚ÇÇ = max(interval(interval(2)*exp(interval(5/4)))*(interval(2)/a‚ÇÇ)^(1/4),sqrt(interval(œÄ)/(interval(2)*sqrt(a‚ÇÇ))))
# Computing the fourier series of E‚ÇÅ and E‚ÇÇ defined in Lemma 4.9.
setprecision(80)
E‚ÇÅbig = Sequence(D‚ÇÑFourier(4N,œÄ/d), interval.(big.(zeros(dimension(D‚ÇÑFourier(4N,œÄ/d))))))
setprecision(80)
E‚ÇÇbig = Sequence(D‚ÇÑFourier(4N,œÄ/d), interval.(big.(zeros(dimension(D‚ÇÑFourier(4N,œÄ/d))))))
for n‚ÇÇ = 0:4N
    for n‚ÇÅ = n‚ÇÇ:4N
        setprecision(80)
        E‚ÇÅbig[(n‚ÇÅ,n‚ÇÇ)] = real(interval(big(1))/(interval(big(8))*dbig) * ((-interval(big(1)))^n‚ÇÅ*sinc(n‚ÇÇ)*(interval(big(1))/(interval(big(2))*a‚ÇÅbig-im*n‚ÇÅ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÅbig + im*n‚ÇÅ*interval(big(œÄ))/dbig)) + (-interval(big(1)))^n‚ÇÇ*sinc(n‚ÇÅ)*(interval(big(1))/(interval(big(2))*a‚ÇÅbig-im*n‚ÇÇ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÅbig + im*n‚ÇÇ*interval(big(œÄ))/dbig))))
        setprecision(80)
        E‚ÇÇbig[(n‚ÇÅ,n‚ÇÇ)] = real(interval(big(1))/(interval(big(8))*dbig) * ((-interval(big(1)))^n‚ÇÅ*sinc(n‚ÇÇ)*(interval(big(1))/(interval(big(2))*a‚ÇÇbig-im*n‚ÇÅ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÇbig + im*n‚ÇÅ*interval(big(œÄ))/dbig)) + (-interval(big(1)))^n‚ÇÇ*sinc(n‚ÇÅ)*(interval(big(1))/(interval(big(2))*a‚ÇÇbig-im*n‚ÇÇ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÇbig + im*n‚ÇÇ*interval(big(œÄ))/dbig))))
    end
end
E‚ÇÅ = interval.(Float64.(inf.(E‚ÇÅbig),RoundDown),Float64.(sup.(E‚ÇÅbig),RoundUp) )
E‚ÇÇ = interval.(Float64.(inf.(E‚ÇÇbig),RoundDown),Float64.(sup.(E‚ÇÇbig),RoundUp) )
# Computes a larger operator to convert from D‚ÇÑ to exponential since inner products will be of size 2N.
P2 = interval.(vec(_exp2D‚ÇÑ!(zeros(dimension(D‚ÇÑFourier(2N,œÄ/d))),D‚ÇÑFourier(2N,œÄ/d))))

setprecision(80)
P2big = interval.(big.(vec(_exp2D‚ÇÑ!(zeros(dimension(D‚ÇÑFourier(2N,œÄ/d))),D‚ÇÑFourier(2N,œÄ/d)))))

# Computation of the ùíµ·µ§‚ÇÅ‚ÇÅ bound, the first quantity defined in Lemma 4.9.
print("Computing ùíµ·µ§‚ÇÅ‚ÇÅ")
V‚ÇÅ·¥∫_interval = project(V1,D‚ÇÑFourier(2N,œÄ/d))
V‚ÇÇ·¥∫_interval = project(V2,D‚ÇÑFourier(2N,œÄ/d))
Œ©‚ÇÄ = ExactReal(4)*d^2
#For spike and ring, use lines 457 through 461
E‚ÇÅV‚ÇÅ = _conv_small(E‚ÇÅ,V‚ÇÅ·¥∫_interval, 2N)
_inner_prod_E‚ÇÅV‚ÇÅ = abs(coefficients(P2.*V‚ÇÅ·¥∫_interval)'*coefficients(P2.*E‚ÇÅV‚ÇÅ))
@show _inner_prod_E‚ÇÅV‚ÇÅ
ùíµ·µ§‚ÇÅ‚ÇÅ = sqrt(interval(2))*C‚ÇÄf‚ÇÅ‚ÇÅ*(1-exp(-4a‚ÇÅ*d)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÅ^(interval(3/4))*sqrt(Œ©‚ÇÄ) *sqrt(_inner_prod_E‚ÇÅV‚ÇÅ)  
@show ùíµ·µ§‚ÇÅ‚ÇÅ


# Computation of the ùíµ·µ§‚ÇÅ‚ÇÇ bound, the second quantity defined in Lemma 4.9.
print("Computing ùíµ·µ§‚ÇÅ‚ÇÇ")
# For spike and ring, use lines 477 through 481
E‚ÇÇV‚ÇÇ = _conv_small(E‚ÇÇ,V‚ÇÇ·¥∫_interval, 2N)
_inner_prod_E‚ÇÇV‚ÇÇ = abs(coefficients(P2.*V‚ÇÇ·¥∫_interval)'*coefficients(P2.*E‚ÇÇV‚ÇÇ))
@show _inner_prod_E‚ÇÇV‚ÇÇ
ùíµ·µ§‚ÇÅ‚ÇÇ = sqrt(interval(2))*C‚ÇÄf‚ÇÇ‚ÇÇ*(interval(1)-exp(-4a‚ÇÇ*d)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÇ^(interval(3/4))*sqrt(Œ©‚ÇÄ)*sqrt(_inner_prod_E‚ÇÇV‚ÇÇ)  
@show ùíµ·µ§‚ÇÅ‚ÇÇ

ùíµ·µ§‚ÇÅ‚ÇÉ = ùíµ·µ§‚ÇÅ‚ÇÇ  

#Now, we compute the full ùíµ·µ§‚ÇÅ bound concluding the computation of Lemma 4.9.
ùíµ·µ§‚ÇÅ = sqrt((ùíµ·µ§‚ÇÅ‚ÇÅ + ùíµ·µ§‚ÇÅ‚ÇÉ)^2 + ùíµ·µ§‚ÇÅ‚ÇÇ^2)
@show ùíµ·µ§‚ÇÅ
################################ ùíµ·µ§‚ÇÇ BOUND ######################################################
# Computation of the ùíµ·µ§‚ÇÇ bound defined in Lemma 4.10.
# We begin by computing all the necessary constants.
# We start with C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ,C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ,C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ, and C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ defined in Lemma 4.10.
print("Computing ùíµ·µ§‚ÇÇ")
C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ = a‚ÇÅ^3*sqrt(interval(œÄ/2))*interval(1)/sqrt(a‚ÇÅ + interval(1))*(interval(1) + interval(1)/a‚ÇÅ)
C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ = a‚ÇÅ^2*sqrt(interval(œÄ/2))*(sqrt(interval(2))*a‚ÇÅ + interval(1))

C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ = a‚ÇÇ*sqrt(interval(œÄ/2))*1/sqrt(a‚ÇÇ + interval(1))*(interval(1)+interval(1)/a‚ÇÇ)
C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ = sqrt(interval(œÄ/2))*(sqrt(interval(2))*a‚ÇÇ + interval(1))

# Next, we define the constants C‚±º,ùíû‚ÇÅ‚±º, and ùíû‚ÇÇ‚±º for j = 1,2 defined in Lemma 4.10.
C‚ÇÅ = sqrt(d^2/(interval(16)*a‚ÇÅ^2*interval(œÄ)^5) + interval(1)/a‚ÇÅ^4 + d/a‚ÇÅ^3)
C‚ÇÇ = sqrt(d^2/(interval(16)*a‚ÇÇ^2*interval(œÄ)^5) + interval(1)/a‚ÇÇ^4 + d/a‚ÇÇ^3)
ùíû‚ÇÅ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*exp(-a‚ÇÅ*d)*(C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*exp(-a‚ÇÅ) + C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ)/a‚ÇÅ
ùíû‚ÇÇ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*sqrt(log(interval(2))^2 + interval(2)*log(interval(2)) + interval(2))
ùíû‚ÇÅ‚ÇÇ = interval(2)*sqrt(Œ©‚ÇÄ)*exp(-a‚ÇÇ*d)*(C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ*exp(-a‚ÇÇ) + C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ)/a‚ÇÇ
ùíû‚ÇÇ‚ÇÇ = interval(2)*sqrt(Œ©‚ÇÄ)*C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ*sqrt(log(interval(2))^2 + interval(2)*log(interval(2)) + interval(2))

# Now, we compute 1_ùíü‚ÇÄ¬≤ and 1_ùíü‚ÇÄ, the Fourier series representations of the
# characteristic functions on ùíü‚ÇÄ¬≤ and ùíü‚ÇÄ respectively. We do these computations
# using the functions _char_boundary_coeffs and _char_1D_boundary_coeffs.
print("Computing coefficients of characteristic function")
setprecision(80)
char = _char_boundary_coeffs(4N,frequency(U01_D4)[1],dbig)
setprecision(80)
char1D = _char_1D_boundary_coeffs(4N,frequency(U01_D4)[1],dbig)
#Note that the function char is the characteristic function on all four corners.
# Indeed, since V‚±º·¥∫ is D‚ÇÑ-symmetric, we can compute the norm of V‚±º·¥∫ on all four corners
# and divide by 1/4 to obtain the result. For the norm involving ‚àÇ‚Çì‚ÇÅv‚ÇÅ·¥∫, we upper bound
# by the norm in the upper right corner by the norm on all four corners. This allows us
# to compute the convolution of a D‚ÇÑ and D‚ÇÇ sequence, which is less computationally expensive.
# Indeed, (‚àÇ‚Çì‚ÇÅv‚ÇÅ·¥∫)¬≤ is an even (D‚ÇÇ) function.

# Similarly, char1D is the characteristic function of ùíü‚ÇÄ ‚à™ (-d,-d+1). Since v‚ÇÅ·¥∫(d,‚ãÖ)
# is even, we can take the norm on this domain and multiply by 1/2.
P3 = interval.(exp2cos(2N))
P4 = interval.([1 ; sqrt(2)*ones(2N)])

setprecision(80)
V‚ÇÅ·¥∫big = project(V1,D‚ÇÑFourier(2N,œÄ/d))
setprecision(80)
·πº‚ÇÅbig = _·πº‚±º_coeffs(V‚ÇÅ·¥∫big)
setprecision(80)
V‚ÇÅ·¥∫dbig = _sequence_on_boundary(V‚ÇÅ·¥∫big)

setprecision(80)
V‚ÇÇ·¥∫big = project(V2,D‚ÇÑFourier(2N,œÄ/d))
setprecision(80)
·πº‚ÇÇbig = _·πº‚±º_coeffs(V‚ÇÇ·¥∫big)
setprecision(80)
V‚ÇÇ·¥∫dbig = _sequence_on_boundary(V‚ÇÇ·¥∫big)

char = interval.(Float64.(inf.(char),RoundDown),Float64.(sup.(char),RoundUp) ) 
char1D = interval.(Float64.(inf.(char1D),RoundDown),Float64.(sup.(char1D),RoundUp) ) 
·πº‚ÇÅ_interval = interval.(Float64.(inf.(·πº‚ÇÅbig),RoundDown),Float64.(sup.(·πº‚ÇÅbig),RoundUp) ) 
V‚ÇÅ·¥∫d_interval = interval.(Float64.(inf.(V‚ÇÅ·¥∫dbig),RoundDown),Float64.(sup.(V‚ÇÅ·¥∫dbig),RoundUp) ) 
·πº‚ÇÇ_interval = interval.(Float64.(inf.(·πº‚ÇÇbig),RoundDown),Float64.(sup.(·πº‚ÇÇbig),RoundUp) ) 
V‚ÇÇ·¥∫d_interval = interval.(Float64.(inf.(V‚ÇÇ·¥∫dbig),RoundDown),Float64.(sup.(V‚ÇÇ·¥∫dbig),RoundUp) ) 


# We now compute each ùíµ·µ§‚ÇÇ‚±º bound for  j = 1,2,3. Beginning with ùíµ·µ§‚ÇÇ‚ÇÅ,
print("Computing ùíµ·µ§‚ÇÇ‚ÇÅ")
char·πº‚ÇÅ = __conv_small(char,·πº‚ÇÅ_interval,2N)
_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ = abs(coefficients(P3.*char·πº‚ÇÅ)'*coefficients(P3.*·πº‚ÇÅ_interval))
@show _boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ

charV‚ÇÅ = _conv_small(char,V‚ÇÅ·¥∫_interval,2N)
_boundary_inner_prodV‚ÇÅ = abs(coefficients(P2.*charV‚ÇÅ)'*coefficients(P2.*V‚ÇÅ·¥∫_interval))
@show _boundary_inner_prodV‚ÇÅ

char1DV‚ÇÅd = project(char1D*V‚ÇÅ·¥∫d_interval,space(V‚ÇÅ·¥∫d_interval))
_boundary_inner_prodV‚ÇÅd = abs(coefficients(P4.*char1DV‚ÇÅd)'*coefficients(P4.*V‚ÇÅ·¥∫d_interval))
@show _boundary_inner_prodV‚ÇÅd

CV‚ÇÅ·¥∫ = sqrt(interval(1/8) * sqrt(_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ)*sqrt(_boundary_inner_prodV‚ÇÅ) + interval(1)/(2d) * interval(1/4) * _boundary_inner_prodV‚ÇÅd)

ùíµ·µ§‚ÇÇ‚ÇÅ = interval(4)/sqrt(Œ©‚ÇÄ) * C‚ÇÅ * (ùíû‚ÇÅ‚ÇÅ * sqrt(_inner_prod_E‚ÇÅV‚ÇÅ) + ùíû‚ÇÇ‚ÇÅ*CV‚ÇÅ·¥∫)
@show ùíµ·µ§‚ÇÇ‚ÇÅ

# Next, we compute ùíµ·µ§‚ÇÇ‚ÇÇ
print("Computing ùíµ·µ§‚ÇÇ‚ÇÇ")
char·πº‚ÇÇ = __conv_small(char,·πº‚ÇÇ_interval,2N)
_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ = abs(coefficients(P3.*char·πº‚ÇÇ)'*coefficients(P3.*·πº‚ÇÇ_interval))
@show _boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ

charV‚ÇÇ = _conv_small(char,V‚ÇÇ·¥∫_interval,2N)
_boundary_inner_prodV‚ÇÇ = abs(coefficients(P2.*charV‚ÇÇ)'*coefficients(P2.*V‚ÇÇ·¥∫_interval))
@show _boundary_inner_prodV‚ÇÇ

char1DV‚ÇÇd = project(char1D*V‚ÇÇ·¥∫d_interval,space(V‚ÇÇ·¥∫d_interval))
_boundary_inner_prodV‚ÇÇd = abs(coefficients(P4.*char1DV‚ÇÇd)'*coefficients(P4.*V‚ÇÇ·¥∫d_interval))
@show _boundary_inner_prodV‚ÇÇd

CV‚ÇÇ·¥∫ = sqrt(interval(1/8) * sqrt(_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ)*sqrt(_boundary_inner_prodV‚ÇÇ) + interval(1)/(2d) * interval(1/4) * _boundary_inner_prodV‚ÇÇd)

ùíµ·µ§‚ÇÇ‚ÇÇ = interval(4)/sqrt(Œ©‚ÇÄ) * C‚ÇÇ * (ùíû‚ÇÅ‚ÇÇ * sqrt(_inner_prod_E‚ÇÇV‚ÇÇ) + ùíû‚ÇÇ‚ÇÇ*CV‚ÇÇ·¥∫)
@show ùíµ·µ§‚ÇÇ‚ÇÇ

# Finally, we compute ùíµ·µ§‚ÇÇ‚ÇÉ. Note that we require an additional inner product for its computation.
print("Computing ùíµ·µ§‚ÇÇ‚ÇÉ")
E‚ÇÅV‚ÇÇ = _conv_small(E‚ÇÅ,V‚ÇÇ·¥∫_interval, 2N)
_inner_prod_E‚ÇÅV‚ÇÇ = abs(coefficients(P2.*V‚ÇÇ·¥∫_interval)'*coefficients(P2.*E‚ÇÅV‚ÇÇ))
@show _inner_prod_E‚ÇÅV‚ÇÇ

ùíµ·µ§‚ÇÇ‚ÇÉ =  min(C‚ÇÅ,C‚ÇÇ) *(ùíµ·µ§‚ÇÇ‚ÇÇ/C‚ÇÇ + interval(4)*(Œª1+Œ¥0)/sqrt(Œ©‚ÇÄ)*(ùíû‚ÇÅ‚ÇÅ * sqrt(_inner_prod_E‚ÇÅV‚ÇÇ) + ùíû‚ÇÇ‚ÇÅ*CV‚ÇÇ·¥∫))
@show ùíµ·µ§‚ÇÇ‚ÇÉ

# Finally, we can compute ùíµ·µ§‚ÇÇ
ùíµ·µ§‚ÇÇ = sqrt((ùíµ·µ§‚ÇÇ‚ÇÅ + ùíµ·µ§‚ÇÇ‚ÇÉ)^2 + ùíµ·µ§‚ÇÇ‚ÇÇ^2)
@show ùíµ·µ§‚ÇÇ

    return ùíµ·µ§‚ÇÅ, ùíµ·µ§‚ÇÇ
end 



function exp2cos(N)

    d = ExactReal(2)*(interval.(ones((N+1)^2)))

    d[1] =ExactReal(1);
    for n2=1:N
        d[n2+1] = sqrt(ExactReal(2));
    end

    for n1 = 1:N
        d[n1*(N+1)+1] = sqrt(ExactReal(2));
    end

    return d
end


function exp2sin_cos(N)

    d = ExactReal(2)*(interval.(ones((N+1)*N)))
    for n2=1:N
        d[n2] = sqrt(ExactReal(2));
    end
    return d
end


function exp2cos_sin(N)

    d = ExactReal(2)*(interval.(ones((N+1)*N)))
    for n1 = 1:N
        d[(n1-1)*(N+1)+1] = sqrt(ExactReal(2));
    end
    return d
end






function computation_bounds(U01,V1,V2,r0,Œª1,Œª2,Œ¥0,t,d,SS,D1,D2,ùíµu1,ùíµu2)

    # Construction of the operator L
    ‚àÇ1 = project(Derivative((2,0)), SS, SS,Interval{Float64})
    ‚àÇ2 = project(Derivative((0,2)), SS, SS,Interval{Float64})
    Œî = ‚àÇ1 + ‚àÇ2

    L11 = Œî*Œª1 - I
    L21 = - ExactReal(0)*Œî*Œª1 + (Œª1*Œª2-1)*I
    L22 = Œî - Œª2*I

    DG11 = project(Multiplication(V1),SS,SS,Interval{Float64})
    DG12 = project(Multiplication(V2),SS,SS,Interval{Float64})

    DF = [coefficients(L11)+coefficients(DG11) coefficients(DG12);
          coefficients(L21) coefficients(L22)]
    display("DF created")

    # DF = L + DG ; L = Nothing ; DG = Nothing 
    D,P =  eigen(-mid.(D1).*mid.(DF).*mid.(D2)')

    #### We compute an approximate inverse Pinv for P. Computing the defect nP, we can use a Neumann series argument to compute the real inverse of P as P^{-1} = sum_k (I - Pinv*P)^k Pinv. We propagate the error given by nP in the bounds below. In practice, nP is very small and will not affect the quality of the bounds 
    P = interval.(mid.(D2).*P.*mid.(D1)') ; Pinv = interval.(inv(mid.(P))) ; nP = opnorm(LinearOperator(I - D1.*_matprod(Pinv,P).*D2'),2)
    norm_P = spec_norm(D1.*P.*D2') ; norm_Pinv = spec_norm(D1.*Pinv.*D2')  

    display("norm of Pinv")
    display(norm_Pinv)

    D = _matprod(_matprod(Pinv,DF),P)  ; DF = Nothing
    S = diag(D) ; R = D - Diagonal(S) 

    St = S .+ t ;  Stinv = ExactReal(1) ./ St 

    ####### Computation of bounds Z1i ################
    
    ####### diagonal part of DG(U0) is given by V0[(0,0)]
    display("values of the Z1i")

    ### computation of \|œÄ_N (L-Œ¥0)^{-1}\|_2. For this we compute the eigenvalues of l^{-1}(Œæ) and evaluate the maximum for Œæ \geq (N+1)œÄ/d 
    a1 = ExactReal(1)/abs(V1[(0,0)] - interval(1) - Œª1*(interval(N+1)*œÄ/d)^2) 
    a2 = ExactReal(0)
    a3 = abs(ExactReal(1)-Œª1*Œª2)/(abs(V1[(0,0)] - interval(1) - Œª1*(interval(N+1)*œÄ/d)^2)*abs(Œª2+(interval(N+1)*œÄ/d)^2))
    a4 = ExactReal(1)/abs(Œª2+(interval(N+1)*œÄ/d)^2) 

    ### formula for the eigenvalues of a matrix [a1 a2;a3 a4]
    max_Linv = ExactReal(0.5)*(a1 + a4 + sqrt(interval(4)*a2*a3 + (a1-a4)^2)) 

    Z12 = max_Linv*sqrt(norm(V1-V1[(0,0)],1)^2 + norm(V2,1)^2)
    display("Z12")
    display(Z12)

    Z13 = spec_norm((D1.*Stinv).*R.*D2')*(ExactReal(1)+ nP*norm_Pinv/(ExactReal(1)-nP))
    display("Z13")
    display(Z13)

    N1 = 50 ; V1_p = project(V1,CosFourier(N1, œÄ/d)‚äóCosFourier(N1, œÄ/d)) ; V12 = V1_p*V1_p
    V2_p = project(V2,CosFourier(N1, œÄ/d)‚äóCosFourier(N1, œÄ/d)) ; V22 = V2_p*V2_p
    DG11 = project(Multiplication(V1_p),SS,SS,Interval{Float64})
    DG12 = project(Multiplication(V2_p),SS,SS,Interval{Float64})


    M1 = coefficients(project(Multiplication(V12),SS, SS, Interval{Float64})) - _matprod(coefficients(DG11),coefficients(DG11))
    M2 = coefficients(project(Multiplication(V22),SS, SS, Interval{Float64})) - _matprod(coefficients(DG12),coefficients(DG12))

    M1 = [M1 M2;
          ExactReal(0)*M1 ExactReal(0)*M2]

    Z14 = sqrt(spec_norm((D1.*Stinv).*_matprod(_matprod(Pinv,M1),Pinv').*((Stinv.*D2)')))*(ExactReal(1)+ nP*norm_Pinv/(ExactReal(1)-nP) + norm_Pinv*sqrt(norm(V1_p-V1,1)^2+norm(V2_p-V2,1)^2)*maximum(Stinv))
    display("Z14")
    display(Z14)

    Z11 = max_Linv*sqrt(spec_norm(D1.*_matprod(_matprod(P',M1),P).*D2'))
    display("Z11")
    display(Z11)


    ###### Computation of the bounds ùíû1*r0 an ùíû2*r0

    L = [coefficients(L11) interval(0)*coefficients(L11);
        coefficients(L21) coefficients(L22)]
    norm_SPL = spec_norm((D1.*Stinv).*_matprod(Pinv,L-Œ¥0*I).*D2')*(ExactReal(1)+ nP*norm_Pinv/(ExactReal(1)-nP))

    display("value norm SPL")
    display(norm_SPL)

    ùíû1 = up_Linv*maximum([Œ±2 Œ±1+abs(Œª1*Œª2-interval(1))/(Œª2+Œªmax)*(norm(U01,1)+Œ∫*r0)])*Œ∫*r0
    ùíû2 = norm_SPL*up_Linv*maximum([Œ±2 Œ±1+abs(Œª1*Œª2-interval(1))/(Œª2+Œªmax)*(norm(U01,1)+Œ∫*r0)])*Œ∫*r0

    display("values of the ùíûi")
    display(ùíû1)
    display(ùíû2)

    ########## Computation of the bound ùíµu3

    ùíµu3 = norm_SPL*ùíµu2

    display("value of ùíµu3")
    display(ùíµu3)

    ######### Computation of œµ


    if sup(ùíû1)<1
        Œ∫1 = (ùíµu1 + ùíû1)/(ExactReal(1)-ùíû1)
        display("Œ∫1")
        display(Œ∫1)
        if sup(Z12 + ùíµu2 + sqrt(ExactReal(1) + Œ∫1^2)*ùíû1) < 1
            if sup(Z12 + ùíµu2) < 1
                Œ∫2 = (Z11 + (ùíµu2 + sqrt(ExactReal(1) + Œ∫1^2)*ùíû1)*norm_P)/(ExactReal(1) - (Z12 + ùíµu2 + sqrt(ExactReal(1) + Œ∫1^2)*ùíû1))
                display("Œ∫2")
                display(Œ∫2)
                œµq = Z13 + Z14*(Z11 + ExactReal(2)*ùíµu2*norm_P)/(ExactReal(1) - Z12 - ExactReal(2)*ùíµu2) + ExactReal(2)*ùíµu3*(norm_P + (Z11 + ExactReal(2)*ùíµu2*norm_P)/(ExactReal(1) - Z12 - ExactReal(2)*ùíµu2))
                œµ = Z13 + Z14*Œ∫2 + (ùíµu3 + ùíû2*sqrt(ExactReal(1) + Œ∫1^2))*(norm_P + Œ∫2)
                return maximum([œµ œµq]),S
            else 
                display("third condition not respected")
                return Nan
            end
        else 
            display("second condition not respected")
            return Nan 
        end 
    else 
        display("first condition not respected")
        return Nan 
    end 
   
end

